// Prisma schema for Podcast Index Manager
// Mirrors PodcastIndex.org feed and episode metadata while keeping the
// structure lean for operational dashboards.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Podcast {
  id                    Int       @id @default(autoincrement())
  podcast_index_id      Int?      @unique(map: "podcasts_podcast_index_id_unique")
  podcast_guid          String?   @unique(map: "podcasts_podcast_guid_unique")
  title                 String
  author                String?
  owner_name            String?
  language              String?   @db.VarChar(32)
  image                 String?
  artwork               String?
  description           String?   @db.Text
  categories            Json?
  last_update_time      DateTime?
  last_crawl_time       DateTime?
  last_parse_time       DateTime?
  newest_item_published DateTime?
  episode_count         Int?      @default(0)
  explicit              Boolean?  @default(false)
  medium                String?   @db.VarChar(32)
  locked                Boolean?  @default(false)
  feed_url              String?   @unique(map: "podcasts_feed_url_unique")
  website_url           String?
  funding               Json?
  value                 Json?
  created_at            DateTime  @default(now())
  updated_at            DateTime  @updatedAt

  episodes              Episode[]
  sync_logs             SyncLog[]

  @@index([title], map: "podcasts_title_idx", type: Hash)
  @@index([language], map: "podcasts_language_idx")
  @@index([updated_at(sort: Desc)], map: "podcasts_updated_idx")
}

model Episode {
  id                Int       @id @default(autoincrement())
  podcast_id        Int
  podcast           Podcast   @relation(fields: [podcast_id], references: [id], onDelete: Cascade)
  podcast_index_id  BigInt?   @unique(map: "episodes_podcast_index_id_unique")
  guid              String?   @db.VarChar(255)
  title             String
  description       String?   @db.Text
  link              String?
  enclosure_url     String?   @db.Text
  enclosure_type    String?   @db.VarChar(128)
  enclosure_length  Int?      @default(0)
  duration          Int?
  explicit          Boolean?  @default(false)
  image             String?
  season            Int?
  episode           Int?
  transcript_url    String?
  chapters_url      String?
  persons           Json?
  social_interact   Json?
  value             Json?
  date_published    DateTime?
  date_crawled      DateTime?
  created_at        DateTime  @default(now())
  updated_at        DateTime  @updatedAt

  @@unique([podcast_id, guid], map: "episodes_podcast_guid_unique")
  @@index([podcast_id, date_published(sort: Desc)], map: "episodes_podcast_published_idx")
  @@index([date_published(sort: Desc)], map: "episodes_published_idx")
  @@index([title], map: "episodes_title_idx", type: Hash)
}

model SyncLog {
  id          Int        @id @default(autoincrement())
  podcast_id  Int?
  podcast     Podcast?   @relation(fields: [podcast_id], references: [id], onDelete: Cascade)
  job_type    String     @db.VarChar(64)
  status      SyncStatus
  started_at  DateTime   @default(now())
  finished_at DateTime?
  payload     Json?
  error       Json?
  message     String?    @db.Text

  @@index([status, started_at(sort: Desc)], map: "sync_logs_status_started_idx")
  @@index([podcast_id, started_at(sort: Desc)], map: "sync_logs_podcast_started_idx")
}

enum SyncStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
}

model SyncCursor {
  id         String   @id
  cursor     String
  updated_at DateTime @updatedAt
}
