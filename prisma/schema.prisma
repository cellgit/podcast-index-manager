// Prisma schema for Podcast Index Manager
// Mirrors PodcastIndex.org feed and episode metadata while keeping the
// structure lean for operational dashboards.

generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "linux-arm64-openssl-3.0.x", "linux-musl-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Podcast {
  id                         Int       @id @default(autoincrement())
  podcast_index_id           Int       @unique(map: "podcasts_podcast_index_id_unique")
  podcast_guid               String?   @unique(map: "podcasts_podcast_guid_unique")
  title                      String
  url                        String    @unique(map: "podcasts_url_unique")
  original_url               String?
  link                       String?
  description                String?   @db.Text
  author                     String?
  owner_name                 String?
  owner_email                String?
  image                      String?
  artwork                    String?
  last_update_time           DateTime?
  last_crawl_time            DateTime?
  last_parse_time            DateTime?
  last_good_http_status_time DateTime?
  last_http_status           Int?
  content_type               String?
  itunes_id                  Int?
  itunes_type                String?
  generator                  String?
  language                   String?   @db.VarChar(64)
  explicit                   Boolean?  @default(false)
  type                       Int?
  medium                     String?   @db.VarChar(32)
  dead                       Int?      @default(0)
  priority                   Int?
  in_polling_queue           Boolean?
  chash                      String?
  created_on                 DateTime?
  episode_count              Int?      @default(0)
  crawl_errors               Int?      @default(0)
  parse_errors               Int?      @default(0)
  locked                     Boolean?  @default(false)
  image_url_hash             BigInt?
  oldest_item_pubdate        DateTime?
  newest_item_pubdate        DateTime?
  popularity                 Int?
  trend_score                Int?
  duplicate_of_feed_id       Int?
  value_created_on           DateTime?
  value_block                String?   @db.Text
  funding_url                String?
  funding_message            String?
  value_model_type           String?
  value_model_method         String?
  value_model_suggested      String?
  created_at                 DateTime  @default(now())
  updated_at                 DateTime  @updatedAt

  episodes           Episode[]
  sync_logs          SyncLog[]
  categories         PodcastCategory[]
  value_destinations PodcastValueDestination[]
  collection_items   PodcastCollectionItem[]
  editorial          PodcastEditorial?

  @@index([title], map: "podcasts_title_idx", type: Hash)
  @@index([language], map: "podcasts_language_idx")
  @@index([updated_at(sort: Desc)], map: "podcasts_updated_idx")
  @@index([podcast_index_id], map: "podcasts_index_id_idx")
  @@index([itunes_id], map: "podcasts_itunes_idx")
  @@map("podcasts")
}

model Episode {
  id                    Int       @id @default(autoincrement())
  podcast_id            Int
  podcast               Podcast   @relation(fields: [podcast_id], references: [id], onDelete: Cascade)
  feed_id               Int
  podcast_index_id      BigInt?   @unique(map: "episodes_podcast_index_id_unique")
  guid                  String?   @db.VarChar(512)
  title                 String
  description           String?   @db.Text
  link                  String?
  date_published        DateTime?
  date_crawled          DateTime?
  enclosure_url         String?   @db.Text
  enclosure_type        String?   @db.VarChar(128)
  enclosure_length      Int?      @default(0)
  duration              Int?
  explicit              Boolean?  @default(false)
  episode               Int?
  episode_type          String?   @db.VarChar(32)
  season                Int?
  image                 String?
  image_url_hash        BigInt?
  feed_itunes_id        Int?
  feed_image            String?
  feed_image_url_hash   BigInt?
  feed_url              String?
  feed_title            String?
  feed_author           String?
  feed_language         String?
  feed_dead             Int?
  feed_duplicate_of     Int?
  transcript_url        String?
  chapters_url          String?
  content_link          String?
  start_time            DateTime?
  end_time              DateTime?
  status                String?   @db.VarChar(32)
  value_model_type      String?
  value_model_method    String?
  value_model_suggested String?
  value_created_on      DateTime?
  created_at            DateTime  @default(now())
  updated_at            DateTime  @updatedAt

  transcripts         EpisodeTranscript[]
  persons             EpisodePerson[]
  soundbites          EpisodeSoundbite[]
  social_interactions EpisodeSocialInteraction[]
  value_destinations  EpisodeValueDestination[]

  @@unique([podcast_id, guid], map: "episodes_podcast_guid_unique")
  @@index([podcast_id, date_published(sort: Desc)], map: "episodes_podcast_published_idx")
  @@index([date_published(sort: Desc)], map: "episodes_published_idx")
  @@index([title], map: "episodes_title_idx", type: Hash)
  @@index([feed_id], map: "episodes_feed_idx")
  @@map("episodes")
}

model SyncLog {
  id          Int        @id @default(autoincrement())
  podcast_id  Int?
  podcast     Podcast?   @relation(fields: [podcast_id], references: [id], onDelete: Cascade)
  job_type    String     @db.VarChar(64)
  status      SyncStatus
  queue_job_id String?   @db.VarChar(64)
  started_at  DateTime   @default(now())
  finished_at DateTime?
  payload     Json?
  error       Json?
  message     String?    @db.Text

  @@index([status, started_at(sort: Desc)], map: "sync_logs_status_started_idx")
  @@index([podcast_id, started_at(sort: Desc)], map: "sync_logs_podcast_started_idx")
  @@index([queue_job_id], map: "sync_logs_queue_job_idx")
  @@map("sync_logs")
}

enum SyncStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
}

model SyncCursor {
  id         String   @id
  cursor     String
  updated_at DateTime @updatedAt

  @@map("sync_cursors")
}

model SyncWorker {
  id         Int      @id @default(autoincrement())
  name       String   @db.VarChar(64)
  status     String   @db.VarChar(32)
  last_seen  DateTime @updatedAt
  details    Json?
  created_at DateTime @default(now())

  @@index([name], map: "sync_workers_name_idx")
  @@map("sync_workers")
}

model Category {
  id         Int      @id
  name       String
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  podcast_categories PodcastCategory[]

  @@map("categories")
}

model PodcastCategory {
  podcast_id  Int
  category_id Int
  podcast     Podcast  @relation(fields: [podcast_id], references: [id], onDelete: Cascade)
  category    Category @relation(fields: [category_id], references: [id], onDelete: Cascade)
  created_at  DateTime @default(now())

  @@id([podcast_id, category_id])
  @@index([category_id], map: "podcast_categories_category_idx")
  @@map("podcast_categories")
}

model PodcastCollection {
  id          Int      @id @default(autoincrement())
  name        String   @db.VarChar(128)
  description String?  @db.Text
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  items PodcastCollectionItem[]

  @@unique([name], map: "podcast_collections_name_unique")
  @@map("podcast_collections")
}

model PodcastCollectionItem {
  collection_id Int
  podcast_id    Int
  position      Int      @default(0)
  added_at      DateTime @default(now())

  collection PodcastCollection @relation(fields: [collection_id], references: [id], onDelete: Cascade)
  podcast    Podcast           @relation(fields: [podcast_id], references: [id], onDelete: Cascade)

  @@id([collection_id, podcast_id])
  @@index([podcast_id], map: "collection_items_podcast_idx")
  @@map("podcast_collection_items")
}

model QualityAlert {
  id          Int       @id @default(autoincrement())
  severity    String    @db.VarChar(16)
  title       String
  description String?   @db.Text
  status      String    @default("open") @db.VarChar(16)
  metadata    Json?
  created_at  DateTime  @default(now())
  updated_at  DateTime  @updatedAt
  resolved_at DateTime?

  @@index([status], map: "quality_alerts_status_idx")
  @@map("quality_alerts")
}

model PodcastValueDestination {
  id           Int      @id @default(autoincrement())
  podcast_id   Int
  podcast      Podcast  @relation(fields: [podcast_id], references: [id], onDelete: Cascade)
  name         String?
  address      String
  type         String?
  split        Int?
  fee          Boolean?
  custom_key   String?
  custom_value String?
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  @@index([podcast_id], map: "podcast_value_destinations_podcast_idx")
  @@map("podcast_value_destinations")
}

model PodcastEditorial {
  podcast_id     Int                      @id
  podcast        Podcast                  @relation(fields: [podcast_id], references: [id], onDelete: Cascade)
  status         PodcastEditorialStatus   @default(ACTIVE)
  priority       PodcastEditorialPriority @default(NORMAL)
  display_title  String?
  display_author String?
  display_image  String?
  tags           String[]                 @default([]) @db.Text
  notes          String?                  @db.Text
  created_at     DateTime                 @default(now())
  updated_at     DateTime                 @updatedAt

  @@map("podcast_editorials")
}

enum PodcastEditorialStatus {
  ACTIVE
  PAUSED
  ARCHIVED
}

enum PodcastEditorialPriority {
  LOW
  NORMAL
  HIGH
}

model EpisodeTranscript {
  id         Int      @id @default(autoincrement())
  episode_id Int
  episode    Episode  @relation(fields: [episode_id], references: [id], onDelete: Cascade)
  url        String
  type       String?
  language   String?
  rel        String?
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@unique([episode_id, url], map: "episode_transcripts_episode_url_unique")
  @@index([episode_id], map: "episode_transcripts_episode_idx")
  @@map("episode_transcripts")
}

model EpisodePerson {
  id              Int      @id @default(autoincrement())
  episode_id      Int
  episode         Episode  @relation(fields: [episode_id], references: [id], onDelete: Cascade)
  person_index_id Int?
  name            String
  role            String?
  group_name      String?  @map("group")
  href            String?
  img             String?
  metadata        Json?
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt

  @@index([episode_id], map: "episode_persons_episode_idx")
  @@map("episode_persons")
}

model EpisodeSoundbite {
  id         Int      @id @default(autoincrement())
  episode_id Int
  episode    Episode  @relation(fields: [episode_id], references: [id], onDelete: Cascade)
  start_time Int
  duration   Int
  title      String
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([episode_id], map: "episode_soundbites_episode_idx")
  @@map("episode_soundbites")
}

model EpisodeSocialInteraction {
  id          Int      @id @default(autoincrement())
  episode_id  Int
  episode     Episode  @relation(fields: [episode_id], references: [id], onDelete: Cascade)
  url         String
  protocol    String
  account_id  String?
  account_url String?
  priority    Int?
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  @@index([episode_id], map: "episode_social_interactions_episode_idx")
  @@map("episode_social_interactions")
}

model EpisodeValueDestination {
  id           Int      @id @default(autoincrement())
  episode_id   Int
  episode      Episode  @relation(fields: [episode_id], references: [id], onDelete: Cascade)
  name         String?
  address      String
  type         String?
  split        Int?
  fee          Boolean?
  custom_key   String?
  custom_value String?
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  @@index([episode_id], map: "episode_value_destinations_episode_idx")
  @@map("episode_value_destinations")
}
